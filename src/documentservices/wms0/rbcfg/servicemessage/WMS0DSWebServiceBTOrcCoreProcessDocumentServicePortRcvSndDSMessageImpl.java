
/**
 * Please modify this class to meet your needs
 * This class is not complete
 */

package documentservices.wms0.rbcfg.servicemessage;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.StringWriter;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;
import java.util.logging.Logger;

import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.activation.FileDataSource;
import javax.imageio.ImageIO;
import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebService;
import javax.jws.soap.SOAPBinding;
import javax.xml.bind.JAXB;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.ws.Action;
import javax.xml.ws.soap.MTOM;

import org.apache.commons.collections.MultiMap;
import org.apache.commons.collections.map.MultiValueMap;


/**
 * This class was generated by Apache CXF 2.2.5
 * Fri Feb 13 14:18:49 IST 2015
 * Generated source version: 2.2.5
 * 
 */
@MTOM
@javax.jws.WebService(
                      serviceName = "BizTalkServiceInstance",
                      portName = "CustomBinding_ITwoWayAsync",
                      targetNamespace = "http://RBCFG.WMS0.DocumentServices/ServiceMessage/",
                      wsdlLocation = "http://10.211.38.145:8999/WS_CXF_Service/services?wsdl",
                      endpointInterface = "documentservices.wms0.rbcfg.servicemessage.WMS0DSWebServiceBTOrcCoreProcessDocumentServicePortRcvSndDSMessage")
                      
public class WMS0DSWebServiceBTOrcCoreProcessDocumentServicePortRcvSndDSMessageImpl implements WMS0DSWebServiceBTOrcCoreProcessDocumentServicePortRcvSndDSMessage {

    private static final Logger log = Logger.getLogger(WMS0DSWebServiceBTOrcCoreProcessDocumentServicePortRcvSndDSMessageImpl.class.getName());

    /* (non-Javadoc)
     * @see documentservices.wms0.rbcfg.servicemessage.WMS0DSWebServiceBTOrcCoreProcessDocumentServicePortRcvSndDSMessage#opRcvSndDSMessage(documentservices.wms0.rbcfg.servicemessage.DocumentServices  part )*
     
    public void opRcvSndDSMessage(javax.xml.ws.Holder<DocumentServices> part) { 
        LOG.info("Executing operation opRcvSndDSMessage");
        System.out.println(part.value);
        try {
        } catch (Exception ex) {
            ex.printStackTrace();
            throw new RuntimeException(ex);
        }
    }*/
    
 // storage related queries
 	final String path = "C:\\Users\\kt820384\\Documents\\Drive_D\\STORE\\";
 	final String insertIndex = "INSERT INTO DOCIDX (TRAN_DATE, TRAN_TIME, DOCGUID, MIME_TYPE) VALUES (?,?,?,?);SELECT @@IDENTITY";
 	final String insertMetadata = "INSERT INTO DOCMETADATA (DOC_ID, META_NAME, META_VALUE, VALUE_SET) VALUES (?,?,?,?)";

 	// getContent related queries
 	final String selectMimetype = "SELECT MIME_TYPE FROM DOCIDX WHERE DOCGUID = ?";
 	
 	//add multiple indexes to existing document
 	final String selectDocid = "SELECT ID FROM DOCIDX WHERE DOCGUID = ?";
 	final String selectValueSet = "SELECT MAX(VALUE_SET) FROM DOCMETADATA WHERE DOC_ID = ?";
 	
 	//remove multiple indexes to existing document
 	final String selectCountValueSet = "SELECT COUNT(DISTINCT VALUE_SET) FROM DOCMETADATA WHERE DOC_ID = ?";

 	final ObjectFactory of = new ObjectFactory();
 	

 	/* (non-Javadoc)
     * @see documentservices.wms0.rbcfg.servicemessage.WMS0DSWebServiceBTOrcCoreProcessDocumentServicePortRcvSndDSMessage#opRcvSndDSMessage(documentservices.wms0.rbcfg.servicemessage.DocumentServices  part )*
     */
 	@Override
    public void opRcvSndDSMessage(javax.xml.ws.Holder<DocumentServices> part) { 
        log.info("Executing operation opRcvSndDSMessage");
 		DocumentServices respObj = part.value;
 		StringWriter sw = new StringWriter();
 		try {
 			
 						/*if (part.value.getDocumentServiceRequest().getTransactionType().equals("1")) {// Search document
 							respObj = searchMetadata(part.value);
 							log.info("TransactionType from request is ..." + part.value.getDocumentServiceRequest().getTransactionType());
 						} else*/ if (part.value.getDocumentServiceRequest().getTransactionType().equals("7")) {// Get Content
 							 getDocContentById(part);
 							log.info("TransactionType from request is ..." + part.value.getDocumentServiceRequest().getTransactionType());
 						} else if (part.value.getDocumentServiceRequest().getTransactionType().equals("8")) {// Store the document
 							log.info("TransactionType from request is ..." + part.value.getDocumentServiceRequest().getTransactionType());
 							 storeDocument(part);
 						} /*else if (part.value.getDocumentServiceRequest().getTransactionType().equals("9")) {//add multi value index
 							respObj = addMultivalueIndex(part.value);
 							log.info("TransactionType from request is ..." + part.value.getDocumentServiceRequest().getTransactionType());
 						} else if (part.value.getDocumentServiceRequest().getTransactionType().equals("10")) {//remove multi value index
 							respObj = removeMultivalueIndex(part.value);
 							log.info("TransactionType from request is ..." + part.value.getDocumentServiceRequest().getTransactionType());
 						} else if (part.value.getDocumentServiceRequest().getTransactionType().equals("11")) {//update document index
 							respObj = updateDocIndex(part.value);
 							log.info("TransactionType from request is ..." + part.value.getDocumentServiceRequest().getTransactionType());
 						}*/


 		} catch (SQLException sql) {
 			sql.printStackTrace();
 		} catch (Exception e) {
 			e.printStackTrace();
 		}
 	}

 	/**
 	 * USE WSDEMO GO
 	 * 
 	 * CREATE TABLE dbo.DOCIDX ( ID INT IDENTITY(1,1) PRIMARY KEY, TRAN_DATE
 	 * NCHAR(10) DEFAULT N'2000-01-01', TRAN_TIME NCHAR(8) DEFAULT N'00-00-00',
 	 * CMP_ID NTEXT NOT NULL, MIME_TYPE NTEXT NOT NULL );
 	 * 
 	 * CREATE TABLE dbo.DOCMETADATA ( ID INT IDENTITY(1,1) PRIMARY KEY, DOC_ID
 	 * INT NOT NULL FOREIGN KEY REFERENCES dbo.DOCIDX(ID), META_NAME NTEXT,
 	 * META_VALUE NTEXT );
 	 * 
 	 * @throws Exception
 	 */

 	private javax.xml.ws.Holder<DocumentServices> storeDocument(javax.xml.ws.Holder<DocumentServices> req) throws Exception {

 		log.info("Service Request Processing ...storing the document");
 		Connection con = null;
 		PreparedStatement psInsertIdx = null, psInsertMeta = null;
 		PreparedStatement psUpdate = null;

 		String tranDate = req.value.getDocumentServiceRequest().getTransactionDate();
 		String tranTime = req.value.getDocumentServiceRequest().getTransactionTime();
 		Documents respDocs = of.createDocuments();
 		Properties multiValueProps = new Properties();
 		multiValueProps.load(new FileInputStream("C:\\Users\\kt820384\\Documents\\properties\\multiValue.properties"));
 		MultiMap metaDataMap = new MultiValueMap();
 		try {
 			con = getConn();
 			psInsertIdx = con.prepareStatement(insertIndex, Statement.RETURN_GENERATED_KEYS);
 			psInsertMeta = con.prepareStatement(insertMetadata, Statement.RETURN_GENERATED_KEYS);

 			
			String DocGUID = UUID.randomUUID().toString();
			String objectMimeType = req.value.getDocumentServiceRequest().getContent().getObjectMimeType();

			psInsertIdx.setString(1, tranDate);
			psInsertIdx.setString(2, tranTime);
			psInsertIdx.setString(3, DocGUID);
			psInsertIdx.setString(4, objectMimeType);
			psInsertIdx.executeUpdate();

			int docId = -1;
			ResultSet rs = psInsertIdx.getGeneratedKeys();
			while (rs.next()) {
				docId = rs.getInt(1);
			}
			rs.close();

			for (MetaDataField m : req.value.getDocumentServiceRequest().getMetaDataFields().getMetaDataField()) {
				 
				metaDataMap.put(m.getName(), m.getValue());
			}
			
			ArrayList multiFields = new ArrayList();
			ArrayList singleFields = new ArrayList();
			ArrayList  valueList = new ArrayList();
			ArrayList  subvalueList = new ArrayList();
			
			Set<String> keys = metaDataMap.keySet();
			
			for(String key : keys){
				if(multiValueProps.containsKey(key)){	
					 valueList = (ArrayList) metaDataMap.get(key);
					 log.info("Retreiving the size of multiple values given to the first Multi Value Property...key is "+key+"..."+valueList.size());
					 break;
				}
			}
			
			List<Map> allValueSetList = new ArrayList<Map>();
			log.info("Creating individual sets of values by storing in a collection ");
			for(int i=0; i<valueList.size(); i++){
				Map valueMap = new HashMap();
				for(String key : keys){
					subvalueList = (ArrayList)metaDataMap.get(key);
					if(multiValueProps.containsKey(key)){	
						valueMap.put(key, subvalueList.get(i));
					} else{
						valueMap.put(key, subvalueList.get(0));
					}
				}
				allValueSetList.add(valueMap);
			}
			
			
			int count = 0;
			log.info("Storing the metadata values in the form of sets");
			for(Map singleValueSet :allValueSetList){
				Set<String> keyset = singleValueSet.keySet();
				count++;
				for(String key : keyset){
					psInsertMeta.setInt(1, docId);
					psInsertMeta.setString(2, key);
					psInsertMeta.setString(3, (String)singleValueSet.get(key));
					psInsertMeta.setInt(4, count);
					psInsertMeta.executeUpdate();
					log.info(count+" value set ..."+"key is "+key+"...value is "+singleValueSet.get(key));
				}
			}
			

			
			
			
			/*if (d.getContent().getObjectContent() != null) {
					FileOutputStream fos = new FileOutputStream(path + DocGUID);
					fos.write(d.getContent().getObjectContent());
					log.info("Service Request Processing ...File has been created in the store folder");
					fos.close();
			}*/
			DataHandler handler = req.value.getDocumentServiceRequest().getContent().getObjectContent();
			if (handler != null) {
				
				//InputStream is = handler.getInputStream();
				OutputStream os = new FileOutputStream(new File(path + DocGUID));
				/*byte[] buffer = new byte[1000];
				int bytesRead = 0;
				while ((bytesRead = is.read(buffer)) != -1) {
					os.write(buffer,0,bytesRead);
				}*/
				handler.writeTo(os);
				log.info("Service Request Processing ...File has been created in the store folder");
				os.close();
			}
			/*if (d.getContent().getObjectContent() != null) {
				File image = new File(path + DocGUID+".gif");
				ImageIO.write((RenderedImage) d.getContent().getObjectContent(), "gif", image);
				log.info("Service Request Processing ...File has been created in the store folder");
			}*/
			
			// Add to response
			MetaDataField mdType = of.createMetaDataField();
			mdType.setName("DocGUID");
			mdType.setValue(DocGUID);
			MetaDataFields mdTypes = of.createMetaDataFields();
			mdTypes.getMetaDataField().add(mdType);

			Document respDoc = of.createDocument();
			respDoc.setMetaDataFields(mdTypes);
			respDocs.getDocument().add(respDoc);
			
 			con.commit();
 		} catch (Exception e) {
 			if (con != null) {
 				con.rollback();
 				con.close();
 			}
 			throw e;
 			// throw new RuntimeException(e);
 		} finally {
 			if (psInsertIdx != null) {
 				psInsertIdx.close();
 			}
 			if (psUpdate != null) {
 				psUpdate.close();
 			}
 			if (con != null) {
 				con.close();
 			}
 		}

 		//DocumentServices resp = of.createDocumentServices();
 		UserAuthResponse userAuth = of.createUserAuthResponse();
 		req.value.setUserAuthResponse(userAuth);

 		TransactionResult tr = of.createTransactionResult();
 		userAuth.setTransactionResult(tr);
 		tr.setResultCode(0);
 		tr.setResultDescription("Success");

 		DocumentServiceResponse docResponseType = of.createDocumentServiceResponse();
 		req.value.setDocumentServiceResponse(docResponseType);
 		docResponseType.setDocuments(respDocs);
 		docResponseType.setIncludeDocumentImage(false);
 		docResponseType.setTransactionGUID(req.value.getDocumentServiceRequest().getTransactionGUID());

 		TransactionResult trType = of.createTransactionResult();
 		docResponseType.setTransactionResult(trType);
 		trType.setResultCode(0);
 		trType.setResultDescription("Success");
 		log.info("Service Request Processing ...Storage has been done successfully");
 		return req;
 	}
 	
 	private javax.xml.ws.Holder<DocumentServices> getDocContentById(javax.xml.ws.Holder<DocumentServices> req) throws Exception {
 		log.info("Service Request Processing ...retrieving the document content based on DOC_GUID");
 		Connection con = null;
 		PreparedStatement psSelectIdx = null;
 		String docGUID = null, mime_type = null;
 		Documents respDocs = of.createDocuments();
 		Document respDoc = of.createDocument();
 		MetaDataFields mdfts = of.createMetaDataFields();
 		
		for (MetaDataField m : req.value.getDocumentServiceRequest().getMetaDataFields().getMetaDataField()) {
			if (m.getName().equalsIgnoreCase("DocGUID")) {
				docGUID = m.getValue();

				// Add DocGUID to response
				MetaDataField mdft = of.createMetaDataField();
				mdft.setName(m.getName());
				mdft.setValue(m.getValue());
				mdfts.getMetaDataField().add(mdft);
				//respDoc.getMetaDataFields().getMetaDataField().add(mdft);
				//respDoc.setMetaDataFields(d.getMetaDataFields());
			}
		}
		respDoc.setMetaDataFields(mdfts);
 		boolean success = false;
 		//byte[] imageInByte = null;
 		DataHandler imagehandler = null;
 		BufferedImage bImage = null;
 		//DocumentServices resp = of.createDocumentServices();
 		try {

 			if (docGUID != null) {
 				log.info("................path ......is"+path+docGUID);
 				File file = new File(path + docGUID);
 				con = getConn();
 				psSelectIdx = con.prepareStatement(selectMimetype);
 				psSelectIdx.setString(1, docGUID);
 				ResultSet selectRs = psSelectIdx.executeQuery();

 				if (selectRs.next()) {
 					mime_type = selectRs.getString(1);
 					log.info("retreived mime_type value from table is " + mime_type);
 				} else {
 					log.info("retreived mime_type value from table is  null");
 				}

 				selectRs.close();
 				psSelectIdx.close();

 				if (file.isFile()) {
 					/*FileInputStream in = new FileInputStream(file);
 					FileChannel channel = in.getChannel();
 					ByteBuffer buffer = ByteBuffer.allocate((int) channel.size());
 					channel.read(buffer);
 					in.close();
 					imageInByte = buffer.array();
 					success = true;*/
 					
 					DataSource source = new FileDataSource(file);
 					imagehandler = new DataHandler(source);
 					if(imagehandler == null){
 						log.info("...........imagehandler is null.................");
 					} else 
 						log.info("...........imagehandler is not null in service.................");
 					
 					//bImage = ImageIO.read(file);
 					success = true;
 				} else log.info(".....................file is null...................");
 			} else log.info(".....................docGUID is null...................");

 			UserAuthResponse userAuth = of.createUserAuthResponse();
 			TransactionResult tr = of.createTransactionResult();
 			userAuth.setTransactionResult(tr);
 			 req.value.setUserAuthResponse(userAuth);
 			
 			DocumentServiceResponse docResponseType = of.createDocumentServiceResponse();
 			 req.value.setDocumentServiceResponse(docResponseType);

 			TransactionResult trType = of.createTransactionResult();
 			docResponseType.setTransactionResult(trType);

 			docResponseType.setIncludeDocumentImage(false);
 			docResponseType.setTransactionGUID(req.value.getDocumentServiceRequest().getTransactionGUID());

 			if (success) {
 				tr.setResultCode(0);
 				tr.setResultDescription("Success");

 				Content contentType = of.createContent();
 				respDoc.setContent(contentType);

 				//contentType.setObjectContent(imageInByte);
 				//contentType.setObjectContent(imagehandler);
 				//contentType.setObjectContent(bImage);
 				
 				if (mime_type.equalsIgnoreCase("image/tiff")) {
 					contentType.setObjectMimeType("image/tiff");
 				} else if (mime_type.equalsIgnoreCase("application/pdf")) {
 					contentType.setObjectMimeType("application/pdf");
 				}

 				respDocs.getDocument().add(respDoc);
 				docResponseType.setDocuments(respDocs);

 				trType.setResultCode(0);
 				trType.setResultDescription("Success");
 				log.info("content retrieval has been completed successfully");

 			} else {
 				tr.setResultCode(1);
 				tr.setResultDescription("Failed to find image");

 				trType.setResultCode(1);
 				trType.setResultDescription("Failed");

 			}
 			req.value.setDocumentServiceResponse(docResponseType);
 		} catch (Exception e) {
 			if (con != null) {
 				con.rollback();
 				con.close();
 			}
 			throw e;
 			// throw new RuntimeException(e);
 		} finally {
 			if (psSelectIdx != null) {
 				psSelectIdx.close();
 			}
 			if (con != null) {
 				con.close();
 			}
 		}

 		return req;
 	}

 	/*private DocumentServices searchMetadata(DocumentServices req) throws Exception {
 		log.info("Service Request Processing  ...retrieving the document details based on the search fields");
 		Connection con = null;
 		PreparedStatement psSearchIdx = null, psSearchMeta = null;

 		String DOC_GUID, id;
 		int rowCount = 0;
 		boolean success = false;
 		Map<String, String> idMap = new HashMap<String, String>();
 		Documents respDocs = of.createDocuments();
 		StringBuilder docGUID_SearchQuery = new StringBuilder("SELECT DOCGUID, ID FROM DOCIDX WHERE ID IN  ( SELECT DISTINCT data.DOC_ID FROM DOCMETADATA data ");
 		StringBuilder joinQuery = new StringBuilder();
 		StringBuilder whereQuery = new StringBuilder();
 		whereQuery.append(" WHERE ");

 		try {

 			for (PackageType p : req.getDocumentServiceRequest().getPackages().getPackage()) {

 				for (DocumentType d : p.getDocuments().getDocument()) {

 					for (MetaDataFieldType m : d.getMetaDataFields().getMetaDataField()) {
 						rowCount++;
 						joinQuery.append(" JOIN DOCMETADATA data" + rowCount + " ON data.DOC_ID = data" + rowCount + ".DOC_ID AND data.VALUE_SET = data"+rowCount+".VALUE_SET ");
 						if (rowCount == 1)
 							whereQuery.append("data" + rowCount + ".META_NAME = '" + m.getName() + "' AND data" + rowCount + ".META_VALUE = '" + m.getValue()
 									+ "'");
 						else if (rowCount > 1)
 							whereQuery.append(" AND data" + rowCount + ".META_NAME = '" + m.getName() + "' AND data" + rowCount + ".META_VALUE = '"
 									+ m.getValue() + "'");
 					}
 				}
 			}
 			docGUID_SearchQuery.append(joinQuery);
 			docGUID_SearchQuery.append(whereQuery);
 			docGUID_SearchQuery.append(") ");
 			log.debug("docGUID_SearchQuery   " + docGUID_SearchQuery);
 			con = getConn();
 			psSearchIdx = con.prepareStatement(docGUID_SearchQuery.toString());

 			ResultSet selectRs = psSearchIdx.executeQuery();

 			while (selectRs.next()) {

 				success = true;
 				DOC_GUID = selectRs.getString(1);
 				id = selectRs.getString(2);
 				log.debug("......in search method .....selectRs....DOCGUID is " + DOC_GUID + "..id is " + id);
 				idMap.put(id, DOC_GUID);
 			}
 			selectRs.close();
 			psSearchIdx.close();

 			psSearchMeta = con.prepareStatement("SELECT DISTINCT META_NAME, META_VALUE FROM DOCMETADATA WHERE DOC_ID = ?");

 			Iterator itr = idMap.keySet().iterator();
 			if (success) {
 				while (itr.hasNext()) {
 					String key = itr.next().toString();

 					psSearchMeta.setString(1, key);
 					MetaDataFields mdfs = of.createMetaDataFields();
 					MetaDataFieldType mdfType = of.createMetaDataFieldType();
 					DocumentType respDoc = of.createDocumentType();

 					ResultSet metaFields = psSearchMeta.executeQuery();
 					mdfType.setName("DocGUID");
 					mdfType.setValue(idMap.get(key));
 					mdfs.getMetaDataField().add(mdfType);
 					respDoc.setMetaDataFields(mdfs);
 					while (metaFields.next()) {
 						MetaDataFieldType mdfType1 = of.createMetaDataFieldType();
 						mdfType1.setName(metaFields.getString(1));
 						mdfType1.setValue(metaFields.getString(2));

 						// Add to response
 						mdfs.getMetaDataField().add(mdfType1);
 						respDoc.setMetaDataFields(mdfs);
 					}
 					respDocs.getDocument().add(respDoc);
 				}
 			}

 			con.commit();
 		} catch (Exception e) {
 			if (con != null) {
 				con.rollback();
 				con.close();
 			}
 			throw e;
 			// throw new RuntimeException(e);
 		} finally {
 			if (psSearchIdx != null) {
 				psSearchIdx.close();
 			}
 			if (psSearchMeta != null) {
 				psSearchMeta.close();
 			}

 			if (con != null) {
 				con.close();
 			}
 		}

 		DocumentServicesType resp = of.createDocumentServicesType();
 		UserAuthResponseType userAuth = of.createUserAuthResponseType();
 		resp.setUserAuthResponse(userAuth);

 		TransactionResultType tr = of.createTransactionResultType();
 		userAuth.setTransactionResult(tr);

 		DocumentServiceResponseType docResponseType = of.createDocumentServiceResponseType();
 		resp.setDocumentServiceResponse(docResponseType);

 		TransactionResultType trType = of.createTransactionResultType();
 		docResponseType.setTransactionResult(trType);

 		docResponseType.setIncludeDocumentImage(false);
 		docResponseType.setTransactionGUID(req.getDocumentServiceRequest().getTransactionGUID());

 		docResponseType.setDocuments(respDocs);

 		if (success) {
 			tr.setResultCode(0);
 			tr.setResultDescription("Success");

 			trType.setResultCode(0);
 			trType.setResultDescription("Success");

 		} else {
 			tr.setResultCode(1);
 			tr.setResultDescription("Failure");

 			trType.setResultCode(1);
 			trType.setResultDescription("Failure");

 		}
 		log.info("Service Request Processing  ...retrieving the document details based on the search fields has been completed");
 		return resp;
 	}
 	
 	private DocumentServices addMultivalueIndex(DocumentServices reqObj) throws Exception {
 		log.info("Service Request Processing ...addMultivalueIndex for the document");
 		Connection con = null;
 		PreparedStatement  psSelectDocid = null ,psSelectValueSet = null ,psInsertMeta = null;
 		String docGUID = null;
 		int docId = 0, maxValue = 0;
 		boolean success = false;
 		Map<String, String> metaDataFields = new HashMap<String, String>();
 		
 		DocumentsType respDocs = of.createDocumentsType();
 		DocumentType respDoc = of.createDocumentType();
 		MetaDataFields mdfts = of.createMetaDataFields();
 		respDoc.setMetaDataFields(mdfts);
 		try {
 			con = getConn();
 			psSelectDocid = con.prepareStatement(selectDocid);
 			psInsertMeta = con.prepareStatement(insertMetadata, Statement.RETURN_GENERATED_KEYS);

 			for (PackageType p : reqObj.getDocumentServiceRequest().getPackages().getPackage()) {

 				for (DocumentType d : p.getDocuments().getDocument()) {
 					
 						for (MetaDataFieldType m : d.getMetaDataFields().getMetaDataField()) {
 							
 							
 							if (m.getName().equalsIgnoreCase("DocGUID")){
 									if(m.getValue() != null && !m.getValue().isEmpty() ) {
 										docGUID = m.getValue();
 										log.info("docGUID value from the request  is " + docGUID);
 										
 										// Add DocGUID to response
 										MetaDataFieldType mdft = of.createMetaDataFieldType();
 										mdft.setName(m.getName());
 										mdft.setValue(m.getValue());
 										respDoc.getMetaDataFields().getMetaDataField().add(mdft);
 										//respDoc.setMetaDataFields(d.getMetaDataFields());
 									} else{
 										log.error("DocGUID value is empty in the request  ");
 										throw new NullPointerException("DocGUID value is empty in the request ");
 									}
 							}else{
 								metaDataFields.put(m.getName(), m.getValue());
 							}
 					}
 				}
 			}
 			psSelectDocid.setString(1, docGUID);
 			ResultSet docIdRs = psSelectDocid.executeQuery();

 			if (docIdRs.next()) {
 				docId = docIdRs.getInt(1);
 				success = (docId > 0 ? true : false);
 				log.info("doc_id value for the given docGUID value is  " + docId + "...success is " + success);
 			} else {
 				log.error("doc_id value retrieved from the table for the given docGUID value is null ");
 			}
 			docIdRs.close();
 			psSelectDocid.close();
 			
 			if (success) {
 				psSelectValueSet = con.prepareStatement(selectValueSet);
 				psSelectValueSet.setInt(1, docId);
 				ResultSet valueSetRs = psSelectValueSet.executeQuery();
 				if (valueSetRs.next()) {
 					maxValue = valueSetRs.getInt(1)+1;
 				}
 				valueSetRs.close();
 				psSelectValueSet.close();
 				
 				for(Map.Entry<String, String> entry: metaDataFields.entrySet()){
 					//if(!entry.getKey().equalsIgnoreCase("DocGUID")){
 						//inserting the meta data fields
 						psInsertMeta.setInt(1, docId);
 						psInsertMeta.setString(2, entry.getKey());
 						psInsertMeta.setString(3, entry.getValue());
 						psInsertMeta.setInt(4, maxValue);
 						psInsertMeta.execute();
 					//}
 				}	
 				psInsertMeta.close();				
 			}
 			con.commit();
 		} catch (Exception e) {
 			if (con != null) {
 				con.rollback();
 				con.close();
 			}
 			throw e;
 			// throw new RuntimeException(e);
 		} finally { 
 			if (psSelectDocid != null) {
 				psSelectDocid.close();
 			}
 			if (psSelectValueSet != null) {
 				psSelectValueSet.close();
 			}
 			if (psInsertMeta != null) {
 				psInsertMeta.close();
 			}
 			if (con != null) {
 				con.close();
 			}
 		}

 		DocumentServicesType resp = of.createDocumentServicesType();
 		UserAuthResponseType userAuth = of.createUserAuthResponseType();
 		resp.setUserAuthResponse(userAuth);

 		TransactionResultType tr = of.createTransactionResultType();
 		userAuth.setTransactionResult(tr);

 		DocumentServiceResponseType docResponseType = of.createDocumentServiceResponseType();
 		resp.setDocumentServiceResponse(docResponseType);

 		TransactionResultType trType = of.createTransactionResultType();
 		docResponseType.setTransactionResult(trType);

 		docResponseType.setIncludeDocumentImage(false);
 		docResponseType.setTransactionGUID(reqObj.getDocumentServiceRequest().getTransactionGUID());

 		respDocs.getDocument().add(respDoc);
 		docResponseType.setDocuments(respDocs);

 		if (success) {
 			tr.setResultCode(0);
 			tr.setResultDescription("Success");

 			trType.setResultCode(0);
 			trType.setResultDescription("Success");
 			log.info("Service Request Processing ...adding the meta data fields has been completed");

 		} else {
 			tr.setResultCode(1);
 			tr.setResultDescription("Failed to add");

 			trType.setResultCode(1);
 			trType.setResultDescription("Failed to add meta fields");
 			log.info("Service Request Processing ...adding the meta data fields has been failed");
 		}
 		return resp;
 	}

 	private DocumentServices removeMultivalueIndex(	DocumentServices reqObj) throws Exception {
 		log.info("Service Request Processing ...removeMultivalueIndex for the document");
 		Connection con = null;
 		PreparedStatement  psSelectDocid = null ,psSelectValueSet = null ,psDeleteMeta = null;
 		String docGUID = null;
 		int docId = 0, maxValue = 0;
 		boolean success = false;
 		Map<String, String> metaDataFields = new HashMap<String, String>();
 		
 		DocumentsType respDocs = of.createDocumentsType();
 		DocumentType respDoc = of.createDocumentType();
 		MetaDataFields mdfts = of.createMetaDataFields();
 		respDoc.setMetaDataFields(mdfts);
 		
 		try {
 			con = getConn();
 			psSelectDocid = con.prepareStatement(selectDocid);

 			for (PackageType p : reqObj.getDocumentServiceRequest().getPackages().getPackage()) {

 				for (DocumentType d : p.getDocuments().getDocument()) {
 					
 						for (MetaDataFieldType m : d.getMetaDataFields().getMetaDataField()) {
 							
 							if (m.getName().equalsIgnoreCase("DocGUID")){
 									if(m.getValue() != null && !m.getValue().isEmpty() ) {
 										docGUID = m.getValue();
 										log.info("docGUID value from the request  is " + docGUID);
 										
 										// Add DocGUID to response
 										MetaDataFieldType mdft = of.createMetaDataFieldType();
 										mdft.setName(m.getName());
 										mdft.setValue(m.getValue());
 										respDoc.getMetaDataFields().getMetaDataField().add(mdft);
 										//respDoc.setMetaDataFields(d.getMetaDataFields());
 									} else{
 										log.error("DocGUID value is empty in the request  ");
 										throw new NullPointerException("DocGUID value is empty in the request ");
 									}
 							}else{
 								metaDataFields.put(m.getName(), m.getValue());
 							}
 					}
 				}
 			}
 			psSelectDocid.setString(1, docGUID);
 			ResultSet docIdRs = psSelectDocid.executeQuery();

 			if (docIdRs.next()) {
 				docId = docIdRs.getInt(1);
 				success = (docId > 0 ? true : false);
 				log.info("doc_id value for the given docGUID value is  " + docId + "...success is " + success);
 			} else {
 				log.error("doc_id value retrieved from the table for the given docGUID value is null ");
 			}
 			docIdRs.close();
 			psSelectDocid.close();
 			
 			if (success) {
 				psSelectValueSet = con.prepareStatement(selectCountValueSet);
 				psSelectValueSet.setInt(1, docId);
 				ResultSet valueSetRs = psSelectValueSet.executeQuery();
 				if (valueSetRs.next()) {
 					maxValue = valueSetRs.getInt(1);
 				}
 				valueSetRs.close();
 				psSelectValueSet.close();
 				
 				if(maxValue > 1){
 					StringBuilder deleteQuery = new StringBuilder("DELETE FROM DOCMETADATA WHERE DOC_ID =  "+docId+" AND VALUE_SET IN ( SELECT data.VALUE_SET FROM DOCMETADATA data ");
 					StringBuilder joinQuery = new StringBuilder();
 					StringBuilder whereQuery = new StringBuilder();
 					int rowCount = 0;
 					whereQuery.append(" WHERE ");
 					for(Map.Entry<String, String> entry: metaDataFields.entrySet()){
 						//if(!entry.getKey().equalsIgnoreCase("DocGUID")){
 							rowCount++;
 							joinQuery.append(" JOIN DOCMETADATA data" + rowCount + " ON data.DOC_ID = data" + rowCount + ".DOC_ID AND data.DOC_ID = "+docId+" AND data.VALUE_SET = data"+rowCount+".VALUE_SET ");
 							if (rowCount == 1)
 								whereQuery.append("data" + rowCount + ".META_NAME = '" + entry.getKey() + "' AND data" + rowCount + ".META_VALUE = '" + entry.getValue()
 										+ "'");
 							else if (rowCount > 1)
 								whereQuery.append(" AND data" + rowCount + ".META_NAME = '" + entry.getKey() + "' AND data" + rowCount + ".META_VALUE = '"
 										+ entry.getValue() + "'");
 						//}
 					}
 					deleteQuery.append(joinQuery);
 					deleteQuery.append(whereQuery);
 					deleteQuery.append(") ");
 					log.debug("deleteQuery   " + deleteQuery);
 					psDeleteMeta = con.prepareStatement(deleteQuery.toString());
 					//psDeleteMeta.setInt(1, docId);
 					boolean result = psDeleteMeta.execute();
 					log.info("Delete metadata fields query result is "+result);
 					psDeleteMeta.close();
 					
 				}else {
 					success = false;
 					log.info("Only one set of meta data fields exist .So removal of multi value index is not possible");
 				}
 			}
 			con.commit();
 		} catch (Exception e) {
 			if (con != null) {
 				con.rollback();
 				con.close();
 			}
 			throw e;
 			// throw new RuntimeException(e);
 		} finally { 
 			if (psSelectDocid != null) {
 				psSelectDocid.close();
 			}
 			if (psSelectValueSet != null) {
 				psSelectValueSet.close();
 			}
 			if (psDeleteMeta != null) {
 				psDeleteMeta.close();
 			}
 			if (con != null) {
 				con.close();
 			}
 		}

 		DocumentServicesType resp = of.createDocumentServicesType();
 		UserAuthResponseType userAuth = of.createUserAuthResponseType();
 		resp.setUserAuthResponse(userAuth);

 		TransactionResultType tr = of.createTransactionResultType();
 		userAuth.setTransactionResult(tr);

 		DocumentServiceResponseType docResponseType = of.createDocumentServiceResponseType();
 		resp.setDocumentServiceResponse(docResponseType);

 		TransactionResultType trType = of.createTransactionResultType();
 		docResponseType.setTransactionResult(trType);

 		docResponseType.setIncludeDocumentImage(false);
 		docResponseType.setTransactionGUID(reqObj.getDocumentServiceRequest().getTransactionGUID());

 		respDocs.getDocument().add(respDoc);
 		docResponseType.setDocuments(respDocs);

 		if (success) {
 			tr.setResultCode(0);
 			tr.setResultDescription("Success");

 			trType.setResultCode(0);
 			trType.setResultDescription("Success");
 			log.info("Service Request Processing ...removing the meta data fields step has been completed");

 		} else {
 			tr.setResultCode(1);
 			tr.setResultDescription("Failed to remove");

 			trType.setResultCode(1);
 			trType.setResultDescription("Failed to remove meta fields");
 			log.info("Service Request Processing ...removing the meta data fields step has been failed");
 		}
 		return resp;
 	}
 	
 	private DocumentServices updateDocIndex(	DocumentServices reqObj) throws Exception {

 		log.info("Service Request Processing ...update MultivalueIndex for the document");
 		Connection con = null;
 		PreparedStatement  psSelectDocid = null ,psSelectValueSet = null ,psDeleteMeta = null, psInsertMeta = null;
 		String docGUID = null;
 		int docId = 0, valueSet = 0;
 		boolean success = false;
 		MultiMap metaDataFields = new MultiValueMap();
 		
 		DocumentsType respDocs = of.createDocumentsType();
 		DocumentType respDoc = of.createDocumentType();
 		MetaDataFields mdfts = of.createMetaDataFields();
 		respDoc.setMetaDataFields(mdfts);
 		
 		try {
 			con = getConn();
 			psSelectDocid = con.prepareStatement(selectDocid);

 			for (PackageType p : reqObj.getDocumentServiceRequest().getPackages().getPackage()) {

 				for (DocumentType d : p.getDocuments().getDocument()) {
 					
 						for (MetaDataFieldType m : d.getMetaDataFields().getMetaDataField()) {
 							
 							if (m.getName().equalsIgnoreCase("DocGUID")){
 									if(m.getValue() != null && !m.getValue().isEmpty() ) {
 										docGUID = m.getValue();
 										log.info("docGUID value from the request  is " + docGUID);
 										
 										// Add DocGUID to response
 										MetaDataFieldType mdft = of.createMetaDataFieldType();
 										mdft.setName(m.getName());
 										mdft.setValue(m.getValue());
 										respDoc.getMetaDataFields().getMetaDataField().add(mdft);
 										//respDoc.setMetaDataFields(d.getMetaDataFields());
 									} else{
 										log.error("DocGUID value is empty in the request  ");
 										throw new NullPointerException("DocGUID value is empty in the request ");
 									}
 							} else{
 								metaDataFields.put(m.getName(), m.getValue());
 							}
 					}
 				}
 			}
 			psSelectDocid.setString(1, docGUID);
 			ResultSet docIdRs = psSelectDocid.executeQuery();

 			if (docIdRs.next()) {
 				docId = docIdRs.getInt(1);
 				success = (docId > 0 ? true : false);
 				log.info("doc_id value for the given docGUID value is  " + docId + "...success is " + success);
 			} else {
 				log.error("doc_id value retrieved from the table for the given docGUID value is null ");
 			}
 			docIdRs.close();
 			psSelectDocid.close();
 			
 			if (success) {
 				Set<String> keys = metaDataFields.keySet();
 				ArrayList  valueList = new ArrayList();
 				Map<String, String> oldValueMap = new HashMap<String, String>();
 				Map<String, String> NewValueMap = new HashMap<String, String>();
 				
 				for(String key : keys){
 					valueList = (ArrayList)metaDataFields.get(key);
 					if(valueList.size() > 2)
 						throw new RuntimeException("Meta data field contains extra values other than updatable value");
 					oldValueMap.put((String)key, (String)valueList.get(0));
 					NewValueMap.put((String)key, (String)valueList.get(1));
 				}
 				
 				//finding the value set of the meta data fields that are need to be updated
 				StringBuilder selectValueSetQuery = 	new StringBuilder("SELECT data.VALUE_SET FROM DOCMETADATA data ");
 				StringBuilder joinQuery = new StringBuilder();
 				StringBuilder whereQuery = new StringBuilder();
 				int rowCount = 0;
 				whereQuery.append(" WHERE ");
 				for(Map.Entry<String, String> entry: oldValueMap.entrySet()){
 						rowCount++;
 						joinQuery.append(" JOIN DOCMETADATA data" + rowCount + " ON data.DOC_ID = data" + rowCount + ".DOC_ID AND data.DOC_ID = "+docId+" AND data.VALUE_SET = data"+rowCount+".VALUE_SET ");
 						if (rowCount == 1)
 							whereQuery.append("data" + rowCount + ".META_NAME = '" + entry.getKey() + "' AND data" + rowCount + ".META_VALUE = '" + entry.getValue()
 									+ "'");
 						else if (rowCount > 1)
 							whereQuery.append(" AND data" + rowCount + ".META_NAME = '" + entry.getKey() + "' AND data" + rowCount + ".META_VALUE = '"
 									+ entry.getValue() + "'");
 				}
 				selectValueSetQuery.append(joinQuery);
 				selectValueSetQuery.append(whereQuery);
 				log.debug("selectValueSet Query   " + selectValueSetQuery);
 				
 				psSelectValueSet = con.prepareStatement(selectValueSetQuery.toString());
 				ResultSet valueSetRs = psSelectValueSet.executeQuery();
 				if (valueSetRs.next()) {
 					valueSet = valueSetRs.getInt(1);
 				}
 				valueSetRs.close();
 				psSelectValueSet.close();
 				
 				//delete the value set of old values 
 				StringBuilder deleteQuery = new StringBuilder("DELETE FROM DOCMETADATA WHERE DOC_ID =  "+docId+" AND VALUE_SET = "+valueSet);
 				psDeleteMeta = con.prepareStatement(deleteQuery.toString());
 				int result = psDeleteMeta.executeUpdate();
 				log.info("Delete metadata fields query result is "+result);
 				psDeleteMeta.close();
 				
 				//insert the new meta data fields for the existing document
 				if(result > 0 ){
 					psInsertMeta = con.prepareStatement(insertMetadata);
 					for(Map.Entry<String, String> entry: NewValueMap.entrySet()){
 						psInsertMeta.setInt(1, docId);
 						psInsertMeta.setString(2, entry.getKey());
 						psInsertMeta.setString(3, entry.getValue());
 						psInsertMeta.setInt(4, valueSet);
 						psInsertMeta.executeUpdate();
 					}
 					psInsertMeta.close();
 				} else{
 					success = false;
 				}
 			}
 			con.commit();
 		} catch (Exception e) {
 			if (con != null) {
 				con.rollback();
 				con.close();
 			}
 			throw e;
 			// throw new RuntimeException(e);  
 		} finally {
 			if (psSelectDocid != null) {
 				psSelectDocid.close();
 			}
 			if (psSelectValueSet != null) {
 				psSelectValueSet.close();
 			}
 			if (psDeleteMeta != null) {
 				psDeleteMeta.close();
 			}
 			if (psInsertMeta != null) {
 				psInsertMeta.close();
 			}
 			if (con != null) {
 				con.close();
 			}
 		}

 		DocumentServicesType resp = of.createDocumentServicesType();
 		UserAuthResponseType userAuth = of.createUserAuthResponseType();
 		resp.setUserAuthResponse(userAuth);

 		TransactionResultType tr = of.createTransactionResultType();
 		userAuth.setTransactionResult(tr);

 		DocumentServiceResponseType docResponseType = of.createDocumentServiceResponseType();
 		resp.setDocumentServiceResponse(docResponseType);

 		TransactionResultType trType = of.createTransactionResultType();
 		docResponseType.setTransactionResult(trType);

 		docResponseType.setIncludeDocumentImage(false);
 		docResponseType.setTransactionGUID(reqObj.getDocumentServiceRequest().getTransactionGUID());

 		respDocs.getDocument().add(respDoc);
 		docResponseType.setDocuments(respDocs);

 		if (success) {
 			tr.setResultCode(0);
 			tr.setResultDescription("Success");

 			trType.setResultCode(0);
 			trType.setResultDescription("Success");
 			log.info("Service Request Processing ...updating the meta data fields has been completed");

 		} else {
 			tr.setResultCode(1);
 			tr.setResultDescription("Failed to update");

 			trType.setResultCode(1);
 			trType.setResultDescription("Failed to update");
 			log.info("Service Request Processing ...updating the meta data fields has been failed");
 		}
 		return resp;
 	
 	}
 	*/

 	private Connection getConn() throws ClassNotFoundException, SQLException, IOException {
 		log.info("service processing the request ...retrieving the db connection details from property file ");
 		Connection con = null;
 		Properties props = new Properties();
 		FileInputStream in = new FileInputStream("C:\\Users\\kt820384\\Documents\\properties\\db.properties");
 		props.load(in);
 		in.close();

 		String driver = props.getProperty("jdbc.driver");
 		if (driver != null) {
 			Class.forName(driver);
 		}

 		String url = props.getProperty("jdbc.url");
 		String username = props.getProperty("jdbc.username");
 		String password = props.getProperty("jdbc.password");

 		con = DriverManager.getConnection(url, username, password);
 		log.info("DB Details are....url is  "+url+"...username is "+username+"...password is "+password);
 		/*
 		 * Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver"); con =
 		 * DriverManager.getConnection(
 		 * "jdbc:sqlserver://10.211.70.180:1433;DatabaseName=KARUNA;", "SONORA",
 		 * "case360@");
 		 */
 		con.setAutoCommit(false);
 		log.info("service processing the request ...db connection object returned ");
 		return con;
 	}

}
